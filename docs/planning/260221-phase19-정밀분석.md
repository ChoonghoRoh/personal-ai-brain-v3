# Phase 19 정밀 분석 보고서

**작성일**: 2026-02-21
**분석 대상**: Phase 19 (P0/P1/P2 작업 4건)
**목적**: 마스터 플랜 수립 전 리스크·의존성·상세 스펙 검증
**상태**: 19-3, 19-4 상세 분석 완료 → 19-1, 19-2 추가 분석 중

---

## 📋 목차

1. [19-1 키워드 추천 엔진 고도화](#0-19-1-키워드-추천-엔진-고도화--p0-최우선)
2. [19-2 통계 메뉴 레이아웃](#0-19-2-통계-메뉴-레이아웃-변경--p2)
3. [19-3 키워드 그룹 관리 UI 리뉴얼](#1-19-3-키워드-그룹-관리-ui-리뉴얼)
4. [19-4 청크 관리 통합·고도화](#2-19-4-청크-관리-통합고도화)
5. [통합 리스크 & 우선순위](#3-통합-리스크--우선순위)
6. [마스터 플랜 프레임워크](#4-마스터-플랜-프레임워크)

---

## 1. 19-3 키워드 그룹 관리 UI 리뉴얼

### 1.1 현황 진단

#### 1.1.1 현재 아키텍처

```
[현재 상태]
├─ 좌측: D&D 기반 트리 (dragstart/drop)
├─ 우측: 읽기 전용 상세 패널
└─ 수정 진입: 상세 패널의 "수정" 버튼 → 모달
   → 2단계 진입 (읽기 → 수정)
```

#### 1.1.2 보고된 문제 5개

| #   | 문제                          | 영향도 | 근본원인                       |
| --- | ----------------------------- | ------ | ------------------------------ |
| 1   | D&D 거의 미사용               | 중간   | UX 직관성 낮음 + 모바일 미지원 |
| 2   | 노드 이동 후 전체 트리 재로드 | 높음   | 성능 최적화 부재               |
| 3   | 클릭 시 시각적 피드백 없음    | 중간   | 비동기 UX 디버깅 부족          |
| 4   | 수정까지 2단계 진입           | 중간   | UX 뎁스 낭비                   |
| 5   | 트리 상태 관리 미흡           | 높음   | 낙관적 UI 실패 시 복구 불가    |

### 1.2 세부 개선항목 분석

#### 📌 UI-1: D&D 제거 + 폴더형 트리 전환

**현재 코드 구조**:

```javascript
// keyword-group-treeview.js
dragstart(e) {
  this.draggedNodeId = e.target.dataset.nodeId;
  e.dataTransfer.effectAllowed = "move";
}

drop(e) {
  e.preventDefault();
  const targetNodeId = this.getTargetNodeId(e);
  const parentId = this.findParentId(targetNodeId);
  // 노드 이동 API 호출
  this.moveNode(this.draggedNodeId, parentId);
}
```

**문제점**:

- D&D 제거 시 `nodeMove()` 로직은 어디로?
- 현재 **유일한 이동 메커니즘인가?**

**제안 대체안**:

```javascript
// 방안 1: 우클릭 컨텍스트 메뉴
onNodeRightClick(nodeId) {
  showContextMenu({
    "이동...": () => showMoveDialog(nodeId),
    "삭제": () => deleteNode(nodeId),
  });
}

// 방안 2: 상세 패널의 드롭다운
<select id="parent-group-select">
  <option value="0">루트</option>
  <option value="1">프로그래밍</option>
  ...
</select>
<button onclick="moveToParent()">이동</button>
```

**체크리스트**:

```
☐ Q1: 현재 moveNode() API 엔드포인트 확인
      POST /api/keyword-groups/{id}/move
      또는 PATCH /api/keyword-groups/{id}

☐ Q2: 이동 권한 체크 필요?
      - 누구나 이동 가능?
      - 관리자만?

☐ Q3: 순환 참조 방지?
      (A의 자식에 A를 이동 시도)
      → API 백엔드에서 체크?
      → FE에서 상제 노드 선택 비활성화?
```

**예상 영향**:

- ✅ 모바일 완벽 지원 (우클릭 메뉴 → 터치 메뉴로 변환)
- ✅ 마우스 정밀도 필요 없음 (D&D 터치 어려움)
- ⚠️ 사용자 재학습 필요

---

#### 📌 UI-2: 클릭 즉시 피드백 + 노드 이동 성능

**현재 문제**:

```
사용자 노드 클릭
  ↓ (0~1초 대기)
아무 피드백 없음
  ↓ (API 응답까지 몇 초)
우측 패널 갱신
```

**제안 개선**:

```
사용자 노드 클릭
  ↓ (0ms)
[즉시 UI 반응]
├─ CSS .selected 클래스 적용 (노드 하이라이트)
├─ 우측 패널 스피너 표시
└─ API 호출 (백그라운드)
   ↓ (응답 도착)
├─ 우측 패널 콘텐츠 렌더링
└─ 스피너 사라짐
```

**상태 관리 전략** (낙관적 UI):

```javascript
// 노드 이동 시
class TreeState {
  constructor() {
    this.tree = []; // 현재 DOM 상태
    this.backup = []; // 이전 상태 백업
  }

  moveNode(nodeId, newParentId) {
    // 1. 백업 저장
    this.backup = JSON.parse(JSON.stringify(this.tree));

    // 2. DOM 즉시 업데이트 (낙관적)
    this.updateDOM(nodeId, newParentId);
    this.render();

    // 3. API 호출
    api
      .moveNode(nodeId, newParentId)
      .then((response) => {
        // 성공 → 그대로 둠
        this.api_success = true;
      })
      .catch((error) => {
        // 실패 → 복구
        this.tree = this.backup;
        this.render();
        showError("이동 실패: " + error.message);
      });
  }
}
```

**성능 최적화**:

```
[Before]
노드 이동 API → 전체 트리 재로드 (모든 노드 fetch)
  시간: ~2초, 데이터: ~100KB

[After]
노드 이동 API → 해당 노드 & 부모 노드만 DOM 업데이트
  시간: ~500ms, 데이터: ~5KB
```

**체크리스트**:

```
☐ Q4: 트리 상태 직렬화 방식?
      ├─ JSON으로 백업? → 메모리 효율?
      ├─ 아니면 이전 노드 정보만 저장?
      └─ 트리 크기 (최대 노드 개수?)

☐ Q5: 동시 편집 시나리오?
      (사용자 A가 이동 중 사용자 B가 동일 노드 삭제)
      → 낙관적 UI 충돌 처리?
      → 충돌 감지 및 재동기화?

☐ Q6: 파이팅 이슈 (Race Condition)?
      (A가 "노드1을 B로 이동" 진행 중, B도 "노드1을 C로 이동" 시도)
      → 어느 쪽이 우선?
      → 백엔드에서 version 관리 필요?
```

**예상 UX 개선**:

- ✅ 체감 속도 4배 향상 (2초→500ms)
- ✅ 사용자 피드백 명확 (로딩 표시 추가)
- ⚠️ 실패 시 혼동 가능 (복구 알림 필수)

---

#### 📌 UI-3: 인라인 편집 모드 (바로 수정)

**현재 플로우** (3단계):

```
1. 트리에서 그룹 선택
2. 우측 패널: [읽기 전용 상세]
3. "수정" 버튼 클릭
4. 모달 표시 (수정 폼)
5. 저장/취소
```

**제안 플로우** (1단계):

```
1. 트리에서 그룹 선택
   → 우측 패널: [즉시 편집 가능한 폼]
      ├─ 이름: <input> (focus 설정)
      ├─ 설명: <textarea>
      ├─ 부모 그룹: <select>
      └─ [저장] [취소] [삭제] 버튼
```

**구현 패턴**:

```javascript
// 기존 모달
showEditGroupModal(groupId) {
  const modal = new EditGroupModal({
    mode: 'modal',
    groupId: groupId,
  });
  modal.show();
}

// 새로운 인라인
showEditGroupForm(groupId) {
  // 기존 showEditGroupModal 로직 재사용
  // 단, mode='inline' 또는 containerElementId 지정
  const form = new EditGroupForm({
    mode: 'inline',
    groupId: groupId,
    container: '#group-detail-panel',
  });
  form.render();
}
```

**체크리스트**:

```
☐ Q7: 기존 모달 코드는 어디서 사용?
      ├─ 다른 페이지에서도 EditGroupModal 사용?
      └─ 모달 유지 vs 인라인으로 완전 전환?

☐ Q8: 필드 유효성 체크?
      ├─ 이름 빈칸 불가?
      ├─ 이름 길이 제한? (min 2, max 50?)
      ├─ 설명 필수? 또는 선택?
      └─ 저장 전 모든 검증 완료?

☐ Q9: 저장 중 UI?
      ├─ 버튼 비활성화?
      ├─ 로딩 스피너?
      └─ 진행률 표시?

☐ Q10: 저장 실패 시?
       ├─ 에러 토스트만?
       ├─ 아니면 폼의 특정 필드 에러 표시?
       ├─ "다시 시도" 버튼?
       └─ 자동 복구 시도?
```

**예상 UX 개선**:

- ✅ 클릭 1회로 편집 가능 (2~3회 감소)
- ✅ 모달 오버레이 제거 (배경 상호작용 가능)
- ⚠️ 폼 검증 실패 시 사용자 혼동 가능

---

#### 📌 UI-4: 트리 헤더 + 검색 통합

**현재** (산재):

```html
<header class="tree-header">
  <h3>키워드 그룹 트리</h3>
</header>
<div class="search-bar">
  <input type="text" placeholder="검색..." />
</div>
<div class="tree-container">...</div>
```

**제안** (통합):

```html
<header class="tree-header-compact">
  <h3>키워드 그룹</h3>
  <div class="header-controls">
    <input type="text" placeholder="검색..." class="compact-search" />
    <select class="depth-filter">
      <option value="0">모든 깊이</option>
      <option value="1">1단계만</option>
      <option value="2">2단계까지</option>
      <option value="5">5단계까지</option>
    </select>
    <button class="btn-refresh">🔄</button>
  </div>
</header>
<div class="tree-container">...</div>
```

**CSS 조정** (반응형):

```css
.header-controls {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* 모바일 (< 600px) */
@media (max-width: 600px) {
  .header-controls {
    flex-direction: column;
  }
  .compact-search {
    width: 100%;
  }
}
```

**체크리스트**:

```
☐ Q11: 모바일 레이아웃?
       ├─ 검색 + 깊이 필터 동시 조작 어려움
       ├─ 1단 vs 2단 선택?
       └─ 터치 타겟 크기 (min 44x44px)?

☐ Q12: 검색과 깊이의 우선순위?
       (검색 + 깊이 2 선택 시)
       ├─ AND 조건? (검색어 + 깊이 2단 모두)
       ├─ OR 조건?
       └─ 현재 구현 확인?
```

---

### 1.3 19-3 통합 리스크 평가

| 리스크                         | 심각도  | 영향               | 대응                           |
| ------------------------------ | ------- | ------------------ | ------------------------------ |
| **D&D 제거 후 대체 UI 미정의** | 🔴 최상 | 노드 이동 불가능   | 결정 필수 (우클릭 or 드롭다운) |
| **상태 관리 미흡**             | 🔴 높음 | 동시 편집 충돌     | 백업/복구 로직 구현            |
| **인라인 편집 폼 검증**        | 🟡 중간 | 잘못된 데이터 저장 | 모든 필드 검증 규칙 정의       |
| **모바일 반응성**              | 🟡 중간 | 터치 사용성 저하   | 반응형 CSS 재검토              |
| **API 호출 성능**              | 🟢 낮음 | 로딩 지연          | 캐싱/최적화 고려               |

---

### 1.4 19-3 스펙 체크리스트

```markdown
## 19-3 상세 구현 스펙

### Phase 1: D&D 제거 + 폴더형 전환

- [ ] 노드 이동 메커니즘 결정 (우클릭 vs 드롭다운)
- [ ] 트리 아이콘 변경 (📁/📂/▶/▼)
- [ ] 아이콘 클릭 시 접기/펼치기 동작 검증
- [ ] D&D 관련 모든 이벤트 제거
- [ ] D&D CSS 제거 (hover, drag-over 스타일)

### Phase 2: UI 피드백 + 성능

- [ ] 클릭 즉시 .selected 클래스 적용
- [ ] 스피너 컴포넌트 추가/재사용
- [ ] 상태 백업/복구 로직 (낙관적 UI)
- [ ] 동시 편집 충돌 감지 및 알림
- [ ] 테스트: 빠른 연속 클릭 시 동작

### Phase 3: 인라인 편집 모드

- [ ] EditGroupForm 컴포넌트 생성 (mode='inline')
- [ ] 필드 검증 규칙 정의 (이름 길이, 필수 여부 등)
- [ ] 저장/취소/삭제 버튼 동작
- [ ] 저장 실패 시 에러 표시 및 복구
- [ ] 테스트: 저장 중 다른 노드 클릭 방지

### Phase 4: 헤더 정리

- [ ] 검색 + 깊이 필터 컴팩트 배치
- [ ] 반응형 CSS (모바일 테스트)
- [ ] 터치 타겟 크기 검증 (44x44px 이상)
```

---

## 2. 19-4 청크 관리 통합·고도화

**참조**: `260221-1802-청크관리-통합-최적화-전략-10대-전문가-분석.md`

### 2.1 현황 분석

#### 2.1.1 현재 3개 메뉴 분산

| 메뉴      | URL                   | 기능                      | 문제                      |
| --------- | --------------------- | ------------------------- | ------------------------- |
| 청크 생성 | `/admin/chunk-create` | 3단계: 파일선택→분할→등록 | 등록 후 메뉴 이동 필수    |
| 청크 승인 | `/admin/approval`     | 승인/거절 + AI 라벨       | 메뉴 분散 → 컨텍스트 손실 |
| 청크 관리 | `/admin/chunk-labels` | 라벨 추가/제거            | 프로세스 일관성 없음      |

**사용자 경험 흐름** (현재):

```
파일 업로드
  ↓ (URL: /admin/chunk-create)
1단계: 파일 선택
2단계: 분할·선택
3단계: 등록 → Draft 저장 ✓
  ↓ [메뉴 이동 필요]
/admin/approval으로 이동
  ↓
청크 목록 재로드
승인/거절
  ↓ [또 다시 메뉴 이동]
/admin/chunk-labels으로 이동
  ↓
라벨 관리
```

**문제점**:

- ❌ 3번 메뉴 이동
- ❌ 각 단계마다 컨텍스트 복구 필요
- ❌ 사용자가 어느 청크를 처리 중인지 헷갈림

#### 2.1.2 10대 페르소나별 공통 요구사항

`260221-1802`에서 도출된 10명의 리더급 전문가 분석:

```
TOP 5 요구사항:
1. 일괄 처리 (Bulk Operation)        — 10명 전원
2. 자동화 강화                        — 9명
3. 다중 선택 + 일괄 작업             — 8명
4. 워크플로우 통합                   — 8명
5. 권한 & 역할 관리 (RBAC)          — 7명
```

**조직별 특수 요구**:

- 국가 연구기관: 대용량 처리, 프리셋
- 화학연구원: 감사 추적, 안전 태깅
- 정책연구원: 다단계 승인, 담당자 추적
- 원자력연구원: 보안 등급, 전자서명
- 관공서: 결재선, 공식 문서 내보내기

---

### 2.2 1단계 (3개월): 탭 기반 통합

#### 2.2.1 구조

```
URL: /admin/knowledge-workflow

┌─────────────────────────────────────┐
│ [1. 생성] [2. 승인] [3. 관리]         │ ← 탭
└─────────────────────────────────────┘
│                                       │
│ [현재 탭의 상세 화면 렌더링]            │
│                                       │
└─────────────────────────────────────┘
```

**핵심 기능** (10대 페르소나 상위 요구 반영):

```
1️⃣ 생성 탭
   ├─ 기존 3단계 UI 유지
   ├─ [빠른 승인] 버튼 추가
   │  → 완료 시 자동 탭2 이동

2️⃣ 승인 탭
   ├─ 청크 목록 (체크박스 추가) ← [요구사항 3]
   ├─ 청크 상세 (우측 패널)
   ├─ [전체 승인] 버튼 (기존 유지)
   ├─ + [전체 승인 + 라벨 적용] ← 자동화 [요구사항 2]
   └─ 완료 후 자동 탭3 이동 (선택적)

3️⃣ 관리 탭
   ├─ 청크 검색
   ├─ 라벨 필터 (분류별)
   ├─ 라벨 추가/제거
   └─ 선택 청크 일괄 라벨 추가 ← [요구사항 3]
```

#### 2.2.2 구현 단계

**Step A: 컴포넌트 통합 (Week 1-2)**

````javascript
// 공통 컴포넌트 추출
| 컴포넌트 | 현재 위치 | 통합 후 |
|---------|---------|--------|
| 청크 목록 | chunk-approval.js + label-manager.js | knowledge-workflow.js |
| 청크 상세 Modal | admin-approval.html + admin-chunk-labels.html | shared-chunk-detail.html |
| 페이징 | pagination-component.js (공통) | 재사용 |
``

**Step B: 탭 + 라우팅 (Week 2-3)**
```javascript
class KnowledgeWorkflow {
  constructor() {
    this.tabs = ['create', 'approval', 'manage'];
    this.currentTab = 'create';
    this.selectedChunks = new Set();
  }

  setTab(tabName) {
    this.currentTab = tabName;
    this.render();
  }

  // 생성 완료 후
  onCreateComplete(chunkIds) {
    this.selectedChunks = new Set(chunkIds);
    this.setTab('approval');  // 자동 전환
  }

  // 승인 완료 후
  onApprovalComplete() {
    // 선택적: 탭3 자동 이동 (설정)
    if (settings.auto_jump_to_manage) {
      this.setTab('manage');
    }
  }
}
````

**Step C: 다중 선택 & 일괄 작업 (Week 3-4)**

```javascript
// 승인 탭: 일괄 승인
<div class="chunk-list">
  <input type="checkbox" id="select-all" />
  <button onclick="bulkApprove()">선택한 청크 승인 (N개)</button>
  // 각 청크
  <div class="chunk-item">
    <input type="checkbox" class="chunk-select" data-chunk-id="123" />
    <span>청크 #123: ...</span>
  </div>
</div>
```

#### 2.2.3 데이터 흐름 & 상태 관리

```
┌─────────────────────────────────────────┐
│ KnowledgeWorkflow State                 │
├─────────────────────────────────────────┤
│ currentTab: 'create' | 'approval' | 'manage'
│ selectedChunks: Set<ChunkId>
│ newChunks: Array<Chunk>  (생성된 청크들)
│ allChunks: Array<Chunk>  (전체 목록, 페이징)
│ filters: {
│   status: 'draft' | 'approved'
│   labels: [LabelId]
│   page: 1
│ }
└─────────────────────────────────────────┘

탭 전환 시:
create → approval: newChunks를 allChunks와 병합
approval → manage: filters.status='approved' 설정
```

#### 2.2.4 기존 메뉴 처리

**옵션 A: 리다이렉트** (권장)

```javascript
// header-component.js
ADMIN_MENU = [
  { path: "/admin/knowledge-workflow", label: "청크 관리", icon: "📋" },
  // 기존 3개 메뉴 제거
];

// 혹시 기존 URL 직접 접근 시
/admin/chunk-create   → /admin/knowledge-workflow?tab=create
/admin/approval       → /admin/knowledge-workflow?tab=approval
/admin/chunk-labels   → /admin/knowledge-workflow?tab=manage
```

**옵션 B: 병렬 유지**

```javascript
ADMIN_MENU = [
  { path: "/admin/knowledge-workflow", label: "청크 관리 (통합)", icon: "📋" },
  { path: "/admin/chunk-create", label: "청크 생성 (레거시)", icon: "➕" },
  // ...
];
// 점진적 마이그레이션
```

#### 2.2.5 스펙 체크리스트 (1단계)

```markdown
## 19-4 1단계 (탭 기반) 스펙

### 아키텍처

- [ ] 새 라우트: /admin/knowledge-workflow
- [ ] 새 HTML: knowledge-workflow.html
- [ ] 새 JS: knowledge-workflow.js (상태 관리)
- [ ] 기존 3개 메뉴 리다이렉트 설정
- [ ] header-component.js 메뉴 업데이트

### 공통 컴포넌트 추출

- [ ] ChunkList (목록 + 페이징 + 체크박스)
- [ ] ChunkDetail (상세 정보 Modal)
- [ ] 두 컴포넌트 import 범위 확인

### 탭 기능

- [ ] 탭 클릭 시 콘텐츠 전환
- [ ] 탭 상태 URL 쿼리 반영 (?tab=create)
- [ ] 포워드/백버튼 동작
- [ ] 다중 선택 상태 탭 전환 시 유지 여부

### 생성 탭 개선

- [ ] [빠른 승인] 버튼 추가 (완료 후 탭2 자동 이동)
- [ ] 생성 완료 시 newChunks 상태 저장
- [ ] 목록 갱신 (승인 탭에서 새 청크 표시)

### 승인 탭 개선

- [ ] 청크 목록에 체크박스 추가
- [ ] [전체 승인 + 라벨 적용] 버튼 추가
- [ ] 선택 개수 표시
- [ ] 일괄 승인 API 호출

### 관리 탭 개선

- [ ] 청크 목록에 체크박스 추가
- [ ] [선택한 청크에 라벨 추가] 버튼
- [ ] 다중 라벨 선택 가능한가?

### 테스트 케이스

- [ ] 생성 완료 → 승인 탭 자동 이동 (새 청크 표시)
- [ ] 승인 탭에서 다중 선택 → 일괄 승인
- [ ] 다중 선택 중 탭 전환 → 상태 유지되는가?
- [ ] URL 쿼리 ?tab=approval 직접 접근
- [ ] 모바일 반응형 (탭 레이아웃)
```

---

### 2.3 2단계 (6개월): Stepper 기반 워크플로우

#### 2.3.1 목표

**before**: 3개 탭을 별개로 생각
**after**: 단일 워크플로우로 인식 (1→2→3 순차 진행)

```
┌──────────────────────────────────┐
│ Stepper: 1️⃣  2️⃣  3️⃣             │
├──────────────────────────────────┤
│ 현재 Step의 화면만 렌더링         │
│ (탭처럼 동작하지만 선택 불가)    │
└──────────────────────────────────┘
```

#### 2.3.2 핵심 기능: "빠른 생성 + 승인"

**제안**:

```
사용자:파일 업로드
  ↓
시스템: [빠른 생성 + 승인] 버튼 표시
사용자: 버튼 클릭
  ↓
시스템:
  1. 파일 분석 (문서 유형 감지)
  2. 최적 분할 방식 선택 (AI)
  3. 청크 생성 (Draft 상태)
  4. AI 추천 라벨 생성
  5. 신뢰도 > 0.8 인 라벨만 자동 적용
  6. Approved 상태로 변경 (승인)
  7. 임베딩 생성 및 벡터 저장
  ↓ (2분 내 완료, 진행률 표시)
완료! → Step 2로 이동 (결과 확인)
```

**예상 효과** (10대 페르소나):

```
국가연구기관: 30분 → 2분 (93% 시간 단축)
화학연구원: 15분 → 2분 (87% 단축, 감사 추적 자동)
관공서: 4시간 → 30분 (92% 단축, 결재선 자동)
```

#### 2.3.3 조건부 자동 승인 규칙

**현재 미지정** → 2단계 스펙에서 정의 필요:

```
자동 승인 조건 결정:
├─ 신뢰도만? (0.8 이상)
├─ 또는 신뢰도 + 문서 유형 (논문 → 0.7, 정책 → 0.9)
├─ 또는 도메인 + 신뢰도 (예: 화학 → 0.95 필수)
└─ 또는 사용자 설정?

예시:
if (confidence > 0.8 && documentType !== 'policy') {
  autoApprove = true;
} else {
  autoApprove = false; // 수동 검토 필요
}
```

#### 2.3.4 UI 구조

```html
<div class="workflow-stepper">
  <!-- Stepper 헤더 -->
  <div class="stepper-header">
    <div class="step" [active]="currentStep==1">
      <span class="step-number">1</span>
      <span class="step-label">생성</span>
    </div>
    <div class="step-connector"></div>
    <div class="step" [active]="currentStep==2">
      <span class="step-number">2</span>
      <span class="step-label">승인</span>
    </div>
    <div class="step-connector"></div>
    <div class="step" [active]="currentStep==3">
      <span class="step-number">3</span>
      <span class="step-label">관리</span>
    </div>
  </div>

  <!-- 컨텐츠 -->
  <div class="stepper-content">
    <!-- Step 1: 생성 -->
    <div *ngIf="currentStep==1" class="step-panel">
      <h2>파일 업로드 & 생성</h2>

      <!-- 빠른 모드 -->
      <div class="quick-mode-panel">
        <div class="file-upload-area" droppable>drag & drop 또는 클릭</div>
        <button class="btn-primary" onclick="quickCreateAndApprove()">🚀 빠른 생성 + 승인</button>
      </div>

      <!-- 고급 모드 -->
      <details>
        <summary>📋 상세 설정 (3단계 프로세스)</summary>
        <!-- 기존 3단계 UI 포함 -->
      </details>
    </div>

    <!-- Step 2: 승인 -->
    <div *ngIf="currentStep==2" class="step-panel">... (기존 approval 화면)</div>

    <!-- Step 3: 관리 -->
    <div *ngIf="currentStep==3" class="step-panel">... (기존 labels 화면)</div>
  </div>

  <!-- 네비게이션 -->
  <div class="stepper-nav">
    <button [disabled]="currentStep==1" (click)="prevStep()">← 이전</button>
    <button [disabled]="currentStep==3" (click)="nextStep()">다음 →</button>
  </div>
</div>
```

#### 2.3.5 2단계 리스크

| 리스크                         | 심각도  | 영향                       |
| ------------------------------ | ------- | -------------------------- |
| **자동 승인 신뢰도 기준 미정** | 🔴 최상 | 오승인 또는 소승인         |
| **Stepper 선택 불가 구현**     | 🟡 중간 | 사용자가 탭 순서 건너뜀    |
| **상태 동기화**                | 🔴 높음 | 각 step의 데이터 불일치    |
| **프론트 복잡도**              | 🟡 중간 | 개발 시간 & 버그 위험 증가 |

---

### 2.4 3단계 (12개월): 전자동 모드 + 도메인 특화

#### 2.4.1 비전: "한 번의 클릭"

```
사용자: 파일 드롭
  ↓ (5초 후)
완료! 청크 50개 생성·승인·라벨 완료
  → 즉시 검색/RAG에 노출
```

#### 2.4.2 AI 자동화 수준

```
Level 3: 완전 자동화 (3단계)
├─ 문서 유형 자동 감지
│  └─ 논문: 섹션 기준, BibTeX 추출
│  └─ 보고서: 헤딩 기준, 담당자 추출
│  └─ 규정: 조항 기준, 법률 번호 태깅
├─ 도메인별 프리셋
│  └─ 화학연구원: 안전 키워드 자동 태깅
│  └─ 정책연구원: 부처명/정책명 자동 추출
│  └─ 관공서: 결재선 템플릿 자동 적용
└─ 신뢰도 적응형
   └─ 초기: 신뢰도 0.8 이상만 자동 승인
   └─ 사용자 피드백 학습
   └─ 1개월 후: 적응형 임계값 (0.6~0.9 변동)
```

#### 2.4.3 도메인 모델 예시

**화학연구원 모드**:

```python
class ChemistryResearcherMode:
  def preprocess(self, document):
    result = {
      'split_strategy': 'paragraph',  # 실험 단계별
      'auto_labels': [
        'chemical_names',  # ChEMBL/PubChem API 연동
        'safety_keywords',
        'experimental_procedure',
      ],
      'safety_check': True,  # 위험 물질 자동 경고
    }
    return result

  def extract_keywords(self, chunk):
    # LLM 프롬프트 특화
    prompt = """
    다음 화학 실험 청크에서 화학물질명을 추출하세요:
    [청크]

    형식: [화학물질: CAS번호]
    예: [벤젠: 71-43-2]
    """
    return llm.generate(prompt)
```

#### 2.4.4 신뢰도 평가 메트릭

```
자동 승인 신뢰도 계산:
confidence = α × semantic_confidence
           + β × domain_confidence
           + γ × user_feedback_score

semantic_confidence: LLM 추천 신뢰도 (0~1)
domain_confidence: 도메인 모델 신뢰도
                   예) 화학 청크인가? (+0.1)
                       안전 키워드인가? (+0.05)
user_feedback_score: 지난 30일 사용자 승인/거부 데이터 학습

예시:
청크 #123: "벤젠은 휘발성이 높아..."
├─ semantic_confidence: 0.75
├─ domain_confidence: 0.90 (화학 청크 감지)
├─ user_feedback_score: 0.88 (이전 유사 청크 90% 승인)
└─ 최종 confidence = 0.3×0.75 + 0.4×0.90 + 0.3×0.88 = 0.85
   → 자동 승인 ✓
```

#### 2.4.5 3단계 리스크 & 필수 자원

| 리스크              | 심각도  | 필요 자원                |
| ------------------- | ------- | ------------------------ |
| **LLM Fine-tuning** | 🔴 최상 | AI/ML 팀 (4명)           |
| **도메인 데이터셋** | 🔴 높음 | 실전 청크 1000+ (조직별) |
| **모델 검증**       | 🟡 중간 | 신뢰도 평가 도구 개발    |
| **실패 복구**       | 🔴 높음 | 롤백·모니터링 시스템     |

**예상 개발 기간**: 6~9개월 (별도 팀)

---

### 2.5 19-4 통합 스펙 체크리스트

```markdown
## 19-4 전체 로드맵 스펙

### 1단계 (3개월) - 탭 기반

[ ] 마이그레이션 경로 확정 (기존 3메뉴 처리)
[ ] 공통 컴포넌트 추출 및 테스트
[ ] 다중 선택 UI 구현
[ ] 탭 상태 URL 쿼리 연동
[ ] 회귀 테스트 (기존 기능 정상동작)

### 2단계 (6개월) - Stepper

[ ] 자동 승인 신뢰도 규칙 정의
[ ] "빠른 생성 + 승인" 워크플로우 설계
[ ] Stepper 컴포넌트 구현
[ ] 각 step 간 데이터 동기화
[ ] 오토 스크롤/포커스 관리

### 3단계 (12개월) - 전자동 + 도메인

[ ] LLM Fine-tuning 파이프라인
[ ] 도메인별 프리셋 정의 (10개 조직)
[ ] 신뢰도 평가 메트릭 개발
[ ] 사용자 피드백 학습 루프
[ ] 모니터링 대시보드 (신뢰도, 오류율 추적)
```

---

## 3. 통합 리스크 & 우선순위

### 3.1 전체 리스크 맵

```
          ┌─────────────────────────┐
      🔴  │ 19-3 상태 관리          │
      높음 │ 19-4 자동 신뢰도        │
          └─────────────────────────┘

          ┌─────────────────────────┐
      🟡  │ 19-3 모바일 반응        │
      중간 │ 19-4 Stepper 복잡도    │
          └─────────────────────────┘

          ┌─────────────────────────┐
      🟢  │ 19-3 UI-4 헤더 정리    │
      낮음 │ 19-4 컴포넌트 추출     │
          └─────────────────────────┘
```

### 3.2 의존성 분석

```
19-1 (키워드 추천)
   └─ 19-4의 "자동 라벨" 기능에 직접 의존
      → 19-1 완료 후 19-4-2단계 착수 권장

19-3 (그룹 UI)
   └─ 독립적 (다른 작업과 의존성 없음)
      → 병렬 진행 가능

19-4 (청크 통합)
   └─ 1단계: 기존 코드 재사용 (병렬 가능)
   └─ 2단계: 19-1 완료 필수
   └─ 3단계: AI/ML 리소스 필요 (별도 팀)
```

### 3.3 우선순위 권고

```
Tier 1 (즉시 착수, 1개월):
├─ 📌 19-4-1단계 (탭 기반 통합)
│  └─ 사용자 체감 효과 최고 (+50% 효율)
│  └─ 리스크 낮음 (기존 코드 재사용)
│  └─ 완료 시 다른 작업 병렬화 가능
│
├─ 📌 19-3 UI 리뉴얼
│  └─ 독립적, 완료 가능성 높음
│  └─ 신뢰도 높은 작업
│
└─ 📌 19-1 키워드 추천 (P0)
   └─ 기초 기능 (품질 수정)

Tier 2 (병렬 진행, 2개월):
├─ 19-2 통계 레이아웃 (P2)
│  └─ 낮은 우선순위이나 쉬운 작업
│
└─ 19-1-FIX-1~5 상세 구현

Tier 3 (이후 검토):
├─ 19-4-2단계 (Stepper, 6개월)
│  └─ 1단계 피드백 후 조정
│
└─ 19-4-3단계 (전자동, 12개월)
   └─ 별도 팀 필요, 중장기 계획
```

---

## 4. 마스터 플랜 프레임워크

### 4.1 개월별 로드맵

```
2026년 2월 (현재)
├─ 19-4-1단계 착수 (탭 기반)
│  ├─ Week 1-2: 공통 컴포넌트 추출
│  ├─ Week 2-3: 탭 + 라우팅
│  └─ Week 3-4: 다중 선택 & 테스트
│
└─ 19-3 병렬 시작
   ├─ UI-1: D&D 제거 (Week 1-2)
   ├─ UI-2: 클릭 피드백 (Week 2-3)
   ├─ UI-3: 인라인 편집 (Week 3-4)
   └─ UI-4: 헤더 정리 (Week 4)

2026년 3월 (1개월 후)
├─ 19-4-1단계 완료 ✓
│  └─ 사용자 테스트 & 피드백 수집
│
├─ 19-3 완료 ✓
│  └─ 모바일 테스트
│
├─ 19-2 통계 시작
│  └─ 레이아웃 조정 (쉬운 작업)
│
└─ 19-1 상세 구현 계속
   └─ FIX-1 ~ FIX-5 병렬

2026년 4~5월 (2~3개월)
├─ 19-1 완료 ✓
│  └─ 코드 리뷰 & QA
│
├─ 19-2 완료 ✓
│
└─ 19-4-2단계 설계 시작
   ├─ 자동 승인 신뢰도 규칙 정의
   ├─ UI 와이어프레임
   └─ Stepper 컴포넌트 설계

2026년 6~9월 (6개월)
├─ 19-4-2단계 구현 (Stepper)
│  ├─ "빠른 생성+승인" 워크플로우
│  ├─ 도메인 모드 프리셋
│  └─ 신뢰도 계산 엔진
│
└─ 사용자 만족도 조사
   └─ 1단계 사용자 피드백 분석

2026년 10월~
└─ 19-4-3단계 계획
   ├─ LLM Fine-tuning (별도 팀)
   ├─ 도메인 데이터셋 준비
   └─ 모니터링 시스템 개발
```

### 4.2 병렬 진행 매트릭스

```
               Week1  Week2  Week3  Week4  Month2
────────────────────────────────────────────────────
19-4-1단계      ████   ████   ████   ████   🔍
병렬진행가능     ✓      ✓      ✓      ✓

19-3-UI    ████   ████   ████   ████   🔍
병렬진행가능✓      ✓      ✓      ✓

19-2-통계           ████   ████   ████   🔍
병렬진행가능            ✓      ✓      ✓

19-1-상세  ████   ████   ████   ████   ████
병렬진행상 ✓      ✓      ✓      ✓      ✓
────────────────────────────────────────────────────

████: 진행 중
🔍: 테스트/QA
✓: 병렬 진행 가능
```

### 4.3 마일스톤 체크리스트

```markdown
## Phase 19 마일스톤

### Milestone A (1개월): 기본 통합 완료

- [ ] 19-4-1단계 일괄 테스트 통과 (회귀 테스트 포함)
- [ ] 19-3 모든 UI 변경 완료 및 모바일 테스트
- [ ] 19-2 레이아웃 변경 완료
- [ ] 사용자 만족도 80% 이상

### Milestone B (2개월): 자동화 기반 구축

- [ ] 19-1 모든 FIX 적용 완료 (키워드 추천 정상)
- [ ] 19-4-2단계 설계 및 프로토타입
- [ ] 신뢰도 규칙 정의 완료
- [ ] 팀 간 스펙 리뷰 완료

### Milestone C (6개월): Stepper 워크플로우 완성

- [ ] 19-4-2단계 완성 (빠른 생성+승인 동작)
- [ ] 10대 페르소나 기준 사용자 테스트
- [ ] 자동화 수준 검증 (시간 단축 70% 이상)
- [ ] 도메인 모드 프리셋 검증 (3개 조직)

### Milestone D (12개월): 전자동 패키지

- [ ] 19-4-3단계 완성 (완전 자동화)
- [ ] 중소기업/대학 도입 테스트
- [ ] SaaS 버전 고려 시작
- [ ] 국가 R&D 비용 절감 효과 정량화
```

---

## 참고: 추가 분석 필요 항목

### 종속성 확인 필요

```
❓ 19-1 (키워드 추천)이 19-4-2단계의 자동 라벨에 미치는 영향?
   → 19-1 완료 전에 19-4-2 설계 시작 가능한가?

❓ Knowledge Admin (기존 청크 승인 탭)과 19-4의 관계?
   → 중복 제거 또는 통합?

❓ 현재 Backend API 구조 (approval.py, knowledge.py)의 확장성?
   → Bulk API 추가 시 성능 영향?
```

### 사용자 테스트 계획

```
1단계 완료 후 (1개월):
- 10명 사용자 테스트 (조직별 1명)
- 특히 "빠른 승인" 기능 신뢰도 평가
- 컨텍스트 손실 개선 측정

2단계 완료 후 (6개월):
- 30명 사용자 (각 조직 3명)
- 전체 워크플로우 평가
- 자동 승인 신뢰도 검증
```

---

## 0. 19-1 키워드 추천 엔진 고도화 — P0 최우선

### 0.1 전략적 중요도

**왜 P0인가?**

```
PAB (Personal AI Brain) 핵심 기능 계층:
┌─────────────────────────────────────┐
│ 최상위: 검색 & 추천 (RAG Output)      │ ← 사용자 직감
├─────────────────────────────────────┤
│ 중간: 벡터 임베딩 & 유사 문서        │ ← 검색 품질 결정
├─────────────────────────────────────┤
│ 하위: 청크 분할 & 라벨 태깅         │
├─────────────────────────────────────┤
│ 기반: 키워드 관리 & 추천             │ ← 모든 상위 레이어의 입력값
└─────────────────────────────────────┘

→ 키워드 품질 = 라벨 품질 = 검색 품질 = 전체 시스템 품질
```

**현재 상태**: 5개 버그로 인한 30% 데이터 손실

### 0.2 상세 버그 & 수정안 (간요)

| FIX #     | 파일                              | 문제                                                          | 심각도  | 해결책                                                      |
| --------- | --------------------------------- | ------------------------------------------------------------- | ------- | ----------------------------------------------------------- |
| **FIX-1** | `recommendation_llm.py` L76       | LLM 공백 분리로 복합 키워드 파괴 (머신 러닝→머신+러닝)        | 🔴 치명 | 쉼표/개행 우선 분리, 공백은 단일 개념어만                   |
| **FIX-2** | `recommendation_llm.py` L93       | ILIKE 부분매칭으로 엉뚱한 라벨 매칭 (화성→화성시, 경기도화성) | 🔴 치명 | 3단계 계층 매칭 (정확/접두사/부분) 도입, Tier별 신뢰도 차등 |
| **FIX-3** | `korean_utils.py` L15             | `+#&@` 제거로 기술명 손상 (C++ → C)                           | 🟡 높음 | 정규식 확장: `[+#&@]` 허용                                  |
| **FIX-4** | `korean_utils.py` L37             | Garbled 판정 과도 (서버less 삭제)                             | 🟡 높음 | 한글→영어 3자+만 허용, 영어→한글은 거부                     |
| **FIX-5** | `keyword-group-suggestion.js` L82 | FE 이중 정제로 유효 키워드 제거                               | 🟡 중간 | extractKeywordsOnly/cleanKeyword 제거, trim만 유지          |

### 0.3 구현 순서

```
Week 1-2: FIX-2 (계층 매칭) + FIX-1 (공백 분리)
Week 3: FIX-3, FIX-4 (유틸 함수)
Week 4: FIX-5 (FE) + E2E 테스트
```

**테스트 케이스** (실제 LLM 응답 시뮬레이션):

```
✓ "머신 러닝, 데이터 분석" → ["머신 러닝", "데이터 분석"] (쉼표 분리)
✓ "Python\nJava\nC++" → ["Python", "Java", "C++"] (개행 분리, 특수문자 유지)
✓ "AI" → 정확 매칭만 (Tier1), (Tier2/3 시도 X)
✓ "화성" → 정확매칭 ["화성"] (Tier3 오매칭 방지)
✓ "서버less" → 유지 (한글→영문 3자+, FIX-4 통과)
```

### 0.4 19-1 리스크

| 리스크                   | 심각도  | 해결                                                      |
| ------------------------ | ------- | --------------------------------------------------------- |
| FIX-2 성능 (DB 쿼리 3배) | 🟡 중간 | Label.name 인덱스 추가                                    |
| LLM 응답 극단 포맷       | 🟡 중간 | 프롬프트 정규화                                           |
| 공유 함수 영향도         | 🟢 낮음 | GroupKeywordRecommender + ChunkLabelRecommender 함께 개선 |

---

## 0. 19-2 통계 메뉴 레이아웃 변경 — P2

### 0.1 요구사항 (간요)

**현재**: 3단 또는 불규칙한 그리드
**목표**: 반응형 1행 + 2단 조합 레이아웃

```
┌─────────────────────────────────────┐
│ 헤더 (1단)                           │  ← 제목 + 새로고침
├─────────────────────────────────────┤
│ 요약 (1행, N개 카드)                │  ← auto-fit 반응형
├─────────────────────────────────────┤
│ 분포 현황 (1행, 3개 차트)           │  ← 문서유형|청크상태|라벨유형
├─────────────────────────────────────┤
│ 일일 트렌드 (1행)                  │  ← 라인 차트
├─────────────────────────────────────┤
│ 인기 라벨 TOP 10 | 프로젝트별 현황 │  ← 2단 (한 줄)
└─────────────────────────────────────┘
```

### 0.2 구현 포인트

**CSS Grid 전략**:

```css
/* Desktop (1200px+): 모든 차트 1행 */
.charts-row {
  grid-template-columns: repeat(3, 1fr);
}

/* Tablet (768~1200px): 차트 2행 */
@media (max-width: 1200px) {
  .charts-row {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Mobile (480~768px): 차트 1행 */
@media (max-width: 768px) {
  .charts-row {
    grid-template-columns: 1fr;
  }
  .details-section {
    grid-template-columns: 1fr;
  } /* 좌우 → 상하 */
}
```

**마크업 샘플**:

```html
<!-- 헤더 -->
<section class="statistics-header">
  <h2>Statistics Dashboard</h2>
  <button class="btn-refresh">🔄 새로고침</button>
</section>

<!-- 요약 -->
<section class="summary-section">
  <div class="cards-container">
    <!-- auto-fit -->
    <div class="summary-card">...</div>
    ×N
  </div>
</section>

<!-- 분포 -->
<section class="distribution-section">
  <div class="charts-row">
    <div class="chart-card">문서 유형 분포</div>
    <div class="chart-card">청크 상태 분포</div>
    <div class="chart-card">라벨 유형 분포</div>
  </div>
</section>

<!-- 상세 (2단) -->
<section class="details-section">
  <div class="details-left">인기 라벨 TOP 10</div>
  <div class="details-right">프로젝트별 현황</div>
</section>
```

### 0.3 19-2 리스크

| 리스크                 | 심각도  | 대응                               |
| ---------------------- | ------- | ---------------------------------- |
| 모바일 레이아웃 검증   | 🟡 중간 | 480/768/1200px 3가지 기준점 테스트 |
| 차트 라이브러리 재사용 | 🟢 낮음 | 기존 Chart.js 호환성 확인          |
| 데이터 로딩 성능       | 🟡 중간 | 100개 항목 이상 시 페이징 검토     |

### 0.4 19-2 스펙 체크리스트 (간요)

```
마크업:
- [ ] 헤더: 1단 (제목+버튼)
- [ ] 요약: 1행 auto-fit
- [ ] 분포: 1행 3단
- [ ] 트렌드: 1행
- [ ] 상세: 2단 좌우

CSS (반응형):
- [ ] Desktop 1200px+: 모든 차트 3단
- [ ] Tablet 768~1200px: 차트 2단 + 상세 2단
- [ ] Mobile 480~768px: 모든 요소 1단

JS/API:
- [ ] 데이터 로드 경로: /api/admin/statistics
- [ ] 새로고침 이벤트 연결
- [ ] 로딩 시간 < 2초

테스트:
- [ ] 7가지 해상도 검증 (480→1920px)
- [ ] 새로고침 동작 (매번 최신 데이터)
- [ ] 빈 데이터 처리 (0 표시)
```

---

**문서 상태**: 19-1, 19-2 추가 분석 완료. 다음은 각 팀별 상세 구현 스펙 작성.

**다음 단계**:

1. Phase 19 작업목록에 본 분석 참고 링크 완료 ✅
2. 각 팀별 상세 스펙 문서 작성 (Backend/Frontend) ← 차기
3. 1개월 후 Milestone A 달성 여부 검토 및 피드백 수집
